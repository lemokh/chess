KING IN CHECK:

    checkPath = pathOfCheck;
    pieceToMove = activeKing;
    kingLit();
    
    if litDivs not empty,
        grey lightens activeKing;
        
        for each kingAttacker,
            if litDivs includes it,
                pushes activeKing to canEatKingAttacker array;
            
            eatOrBlock(kingAttacker.id);

        interceptKingAttacker();
    
    else if only one kingAttacker,
        eatOrBlock(kingAttackers[0].id);

    else endOfGame();

    
    --------------------------------------------------
    kingAttackers = [passivePiece, passivePiece, ...];
    --------------------------------------------------
    
    greyLitPieces = [activePiece, activePiece, ...];
    -----------------------------------------------------
    canEatKingAttacker = [activePiece, activePiece, ...];

    ------------------------------------------------------------

    canBlockPathOfCheck = [ { pathBlocker: __ , emptyiv: __ } ];
    ------------------------------------------------------------
    pinnedPieces = [ { pinner: __ , pinned: __ } ];
    -----------------------------------------------


    function eatOrBlock(kAId) {
        
        activePieceIsPinned = false;
        
        for each activePiece,
            loop through pinnedPieces,
                if activePiece is pinned,
                    activePieceIsPinned = true;
                    break;
        
        if !activePieceIsPinned,
            if activePiece is not king,
                pieceToMove = activePiece;
                
                if activePiece checks kAId,
                    pushes activePiece to canEatKingAttacker array;

                pawnBlocksKingAttacker = true;

                for each id in checkPath,
                    if activePiece checks that id,
                        | pushes {pathBlocker: activePiece, emptyDiv: id} 
                        | to canBlockPathOfCheck array;

            pawnBlocksKingAttacker = false;

        else if activePiece checks kingAttackers[0].id,
            pushes activePiece to canEatKingAttacker array;
    }

    ------------------------------------------------------

    function interceptKingAttacker() {

        greyLitPieces = [...canEatKingAttacker];

        for each obj in canBlockPathOfCheck,
            pushes obj.pathBlocker to greyLitPieces;

        if greyLitPieces is empty,
            endOfGame();

        else for each kingAttacker,
            grey-lightens & click-listens each greyLitPiece, 
                --> selectGreyPiece();
    }

    ----------------------------------------------------------

    function selectGreyPiece(e) {

        un-grey-lightens greyPieceToMove if not undefined;
        removeLitDivHandler(moveGreyPiece);
        
        greyPieceToMove = e.target;
        mainLit-lightens greyPieceToMove;

        if canEatKingAttacker includes greyPieceToMove,
            pushes kingAttackers[0].id to litDivs;
        
        for each obj in canBlockPathOfCheck,
            if obj.pathBlocker === greyPieceToMove,
                pushes obj.emptyDivId to litDivs;
            
        addLitDivHandler(moveGreyPiece);
    }

    ------------------------------------------------------

    function moveGreyPiece(e) {

        un-mainLit-lighens greyPieceToMove;
        
        un-greyLit-lightens & un-click-listens each greyLitPiece,
            --> selectGreyPiece();
        
        greyLitPieces = [];

        removeLitDivHandler(moveGreyPiece);

        if e.target is not empty, 
            eat(e.target);
        
        swapSide(greyPieceToMove, e.target);

        toggleSides();
    }

    --------------------------------------------
    
    function add/removeLitDivHandler(funcName) {
        
        for each litDiv,
            adds/removes 'lit' & click-listener --> funcName;
    }